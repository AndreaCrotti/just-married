#+AUTHOR: Andrea Crotti
#+TITLE: Getting Married with Clojure
#+OPTIONS: num:nil ^:nil tex:t toc:nil reveal_progress:t reveal_control:t reveal_overview:t
#+REVEAL_TRANS: fade
#+REVEAL_SPEED: fast
#+EMAIL: andrea.crotti.0@gmail.com
#+TOC: 


* 
  :PROPERTIES:
  :reveal_background: ./images/enter_page.png
  :END:

* Why 

#+BEGIN_SRC 

#+END_SRC

[[./images/scheming2.gif]]

* The grand plan

- Italian & English public website
- Google maps integration
- Smart RVSP
- Integrated weding registry (Paypal/Stripe integration)
- Notification system
- Database to store guests
- Table generator

* Project management

** Planning

** Deadlines

* The reality

** Some stats

- 9 months of development
- 433 commits
- 50 PRs closed
- 559 Clj SLOC
- 92 Cljc SLOC
- 505 Cljs SLOC

** Backend

- Clojure / Ring
- Postgres
- HoneySQL
- Migratus to handle migrations
- Buddy for authentication
- Clj-pdf to generate labels and placeholders

** Frontend

- Clojurescript
- Reagent
- Re-frame
- Garden for CSS generation
- Responsive Navbar with CSS Grid

** Other

- CircleCI to run tests
- Deploying on Heroku
- HTTPS with lets encrypt and Heroku
- Separate staging and production environments
- Deploy hooks to notify my wife

* Clojure niceties

** One language to rule them all

#+BEGIN_SRC clojure
  (def sections
    [:find-us
     :timeline
     :accommodation
     :gift
     :rvsp])

#+END_SRC

#+BEGIN_SRC clojure
  (ns just-married.css
    (:require [just-married.shared :refer [sections]]))

  (def num-sections (-> sections count))
  (def menu-size (format "repeat(%d, 1fr)" (inc num-sections)))
  
  (def ^:private body-grid-config
      {:display               "grid"
       :grid-gap              "5px"
       :grid-template-columns "auto 80% auto"
       :grid-template-rows    (repeat-word "auto" num-sections)
       :justify-items         "left"
       :justify-content       "center"
       :width                 "90%"})

#+END_SRC

** Maps support

#+BEGIN_SRC clojure
  (def places
    {:lepri {:lat 42.346799
             :lng 14.164534
             :title "Palazzo Lepri"
             :icon "images/rings_small.png"
             :info "Palazzo Lepri"
             :address "Via la Valletta, 6, 66100 Chieti CH, Italy"
             :website "http://www.palazzolepri.it/"
             :description {:it "Palazzo Lepri"
                           :en "Lepri Palace"}}})

  (def map-configs
    {:wedding {:element-id "map"
               :places [:lepri :princi]
               :center {:lat 42.4
                        :lng 14.2}
               :zoom 12
               :map-type-id "roadmap"}

     :accommodation {}})
#+END_SRC

** Maps config in JS

#+BEGIN_SRC javascript
  var config = window.config;
  function addMap(mapConfig) {
      var mapOptions = {
          zoom: mapConfig.zoom,
          center: new google.maps.LatLng(mapConfig.center.lat, mapConfig.center.lng),
          mapTypeId: mapConfig['map-type-id']
      }
      var map = new google.maps.Map(document.getElementById(mapConfig['element-id']), mapOptions);

      mapConfig.places.forEach(function(placeName) {
          var placeConfig = config.places[placeName];
          addMarker(map, placeConfig);
      });
  }

  addMap(config['maps']['wedding']);

#+END_SRC

** Fill in window.config

#+BEGIN_SRC clojure
  (defn home-page
    [{:keys [language]}]
    (let [env (language common/text)
          client-side-config (json/write-str (assoc config
                                                    :language language))]
      [:html {:lang (name language)}
       (common/header env)
       (when settings/google-analytics-key
         [:script common/ga-js])

       [:body
        [:script (format "window['config']=%s" client-side-config)]
        [:div {:id "app"}]
        ;; now we can easily generate some JS that can be then loaded by
        ;; the frontend to decide which page to display for example
        common/app-js
        [:script "just_married.core.init();"]
        [:script {:src "map.js"}]]]))
#+END_SRC

** Labels and placeholders generation

#+BEGIN_SRC clojure

  (def labels-sql
    (-> (h/select :group_name :country :address)
        (h/from :guests-group)
        (h/where [:and
                  [:= :invitation_sent false]])
        (sql/format)))

  (defn labels-api
    [request]
    (with-basic-auth request
      (let [labels-data     (get-labels!)
            labels-pdf-file (labels labels-data)]

        (-> (resp/file-response labels-pdf-file)
            (resp/content-type "application/pdf")))))
#+END_SRC


* Conclusions


